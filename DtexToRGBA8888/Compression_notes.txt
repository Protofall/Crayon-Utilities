Compression notes:
	-For square textures of n by n
		-Compressed texture has 2KB overhead (Code book (Lookup table?))
			-It seems each 2 by 2 set of pixels "becomes one"? not sure how
				-Note for paletted its a code book that corresponds to 2 × 4 pixels (8BPP) or 4 × 4 pixels (4BPP)
		-Texture body is full of indexes and is m by m (Where m is the next power of two down from n (or n * n / 2 / 2))
			-Sega docs say rectangular compressed textures are impossible, but they're actually not.
			I assume if its n by m then the resultant size is (n * m / 2 / 2)
	-There seem to be multiple different compression levels, but I don't know how they work (Ranges from 1/3 to 1/8 compression?)
	-256 codes that correspond to 2 by 2 pixel blocks

	-The relationship between Indexes and code book is similar to the relationship between palette texture data and palette data
	-The index indicates 2 texels (H) × 2 texels (V) of the texture prior to compression
	-The code book is a grouping of units of data for four texels (64 bits), and usually consists of 256 × 64 bits

	-How does compression work on YUV :cold_sweat:
	-The four-texel data of the code book is expanded in a reverse "N" shape, similar to Twiddled format.
	-Whats the difference between small and normal compression?
	-"Normally, when dealing with textures that are 32 × 32 or smaller, it is necessary to group several into a size of at least
		64 × 64 before compressing them." What? This seems to be referring to the weird compression I saw with < 32 by 32 textures
	- 2x2 texels appear to be twiddled themselves? Unclear




4BPP insta
Uncompressed:	48		B	= 16-byte header + (8 * 8 * 0.5)-byte body
Compressed:		2096	B	= 16-byte header + 2048-byte code book + (8 * 8 / 4 / 4)-byte texture-index	= 2060	(Not correct)

8BPP insta
Uncompressed:	80		B	= 16-byte header + (8 * 8 * 1)-byte body
Compressed:		2096	B	= 16-byte header + 2048-byte code book + (8 * 8 / 4 / 2)-byte texture-index	= 2072	(Not correct)

RGB565 instal
Uncompressed:	144		B	= 16-byte header + (8 * 8 * 2)-byte body
Compressed:		2096	B	= 16-byte header + 2048-byte code book + (8 * 8 / 2 / 2)-byte texture-index = 2080??? Where's the extra 16 bytes from?

(Compressed is same for 16 by 16)

For a 32 by 32 image

4BPP insta
Uncompressed:	528		B	= 16-byte header + (8 * 8 * 0.5)-byte body
Compressed:		2128	B	= 16-byte header + 2048-byte code book + (32 * 32 / 4 / 4 = 64)-byte texture-index = 2128

8BPP insta
Uncompressed:	1040	B	= 16-byte header + (8 * 8 * 1)-byte body
Compressed:		2192	B	= 16-byte header + 2048-byte code book + (32 * 32 / 4 / 2 = 128)-byte texture-index = 2192

So compressed textures of under 32 by 32 have a hard-limit of a 32 bytes for the texture-index? Why? And what out rectangular textures like 16 by 64?





This isn't something I'll do, but its an interesting idea on having even smaller textures work on the DC:

The hardware determines that the texture address specified in the Texture Control Word is the start of
the code book data, and uses the address produced by adding 256 x 64-bits to that address as the start of
the index data. Therefore, in order to have a code book with less than 256 elements, use an address in
the middle of the previous texture data as the texture address that is specified in the Texture Control
Word, and then store index data only for the values that correspond to the code book data that was
stored.
